# Software-Engineering

# Professional Programming - about this list

> Give me six hours to chop down a tree and I will spend the first four sharpening the axe. (Abraham Lincoln)

A collection of full-stack resources for programmers.

The goal of this page is to make you a more proficient developer. You'll find only resources that I've found truly inspiring, or that have become timeless classics.

## Principles

- This page is not meant to be comprehensive. I am trying to keep it light and not too overwhelming.
- The selection of articles is opinionated.
- I don't necessarily agree with or endorse every single line that is written in every single one of those resources. The same applies to their authors: I don't endorse everything each of those authors has said and will ever say.

Items:

- üß∞ : list of resources
- üìñ : book
- üéû : video/movie extract/movie/talk
- üèô : slides/presentation
- ‚≠êÔ∏è : must-read
- üìÉ : paper

## Contributing to this list

Feel free to open a PR to contribute!

I will not be adding everything: as stated above, I am trying to keep the list concise.

## Must-read books

I've found these books incredibly inspiring:

- üìñ¬†[The Pragmatic Programmer: From Journeyman to Master](https://pragprog.com/titles/tpp20/): hands-on the most inspiring and useful book I've read about programming.
- üìñ¬†[Code Complete: A Practical Handbook of Software Construction](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670): a nice addition to The Pragmatic Programmer, gives you the necessary framework to talk about code.
- üìñ¬†[Release It!](https://smile.amazon.com/Release-Design-Deploy-Production-Ready-Software/dp/1680502395): this books goes beyond code and gives you best practices for building production-ready software. It will give you about 3 years worth of real-world experience.
- üìñ¬†[Scalability Rules: 50 Principles for Scaling Web Sites](https://smile.amazon.com/Scalability-Rules-Principles-Scaling-Sites/dp/013443160X)
- üìñ¬†[The Linux Programming Interface: A Linux and UNIX System Programming Handbook](http://www.amazon.com/The-Linux-Programming-Interface-Handbook/dp/1593272200): outside of teaching you almost everything you need to know about Linux, this book will give you insights into how software evolves, and the value of having simple & elegant interfaces.
- üìñ¬†[Structure and interpretation of Computer Programs](https://web.mit.edu/6.001/6.037/sicp.pdf)¬†(free): One of the most influential textbooks in Computer Science (written and used at MIT), SICP has been influential in CS education.¬†[Byte](https://en.wikipedia.org/wiki/Byte_(magazine))¬†recommended SICP "for professional programmers who are really interested in their profession".

There are some free books available, including:

- üìñ¬†[Professional software development](http://mixmastamyk.bitbucket.io/pro_soft_dev/): pretty complete and a good companion to this page. The free chapters are mostly focused on software development processes: design, testing, code writing, etc. - and not so much about tech itself.
- üß∞¬†[vhf/free-programming-books](https://github.com/vhf/free-programming-books)
- üß∞¬†[EbookFoundation/free-programming-books](https://github.com/EbookFoundation/free-programming-books/blob/master/books/free-programming-books.md)

## Must-read articles

- [[Practical Advice for New Software Engineers]]
- [[On Being A Senior Engineer]]
- [[Lessons Learned in Software Development]]: one of those articles that give you years of hard-earned lessons, all in one short article. Must read.
- [Things I Learnt The Hard Way](https://blog.juliobiason.me/thoughts/things-i-learnt-the-hard-way/)
    - Spec first, then code
    - Tests make better APIs
    - Future thinking is future trashing
    - Documentation is a love letter to your future self
    - Sometimes, it's better to let the application crash than do nothing
    - Understand and stay away of cargo cult
    - "Right tool for the job" is just to push an agenda
    - Learn the basics functional programming
    - ALWAYS use timezones with your dates
    - ALWAYS use UTF-8
    - Create libraries
    - Learn to monitor
    - Explicit is better than implicit
    - Companies look for specialists but keep generalists longer
    - The best secure way to deal with user data is not to capture it
    - When it's time to stop, it's time to stop
    - You're responsible for the use of your code
    - Don't tell "It's done" when it's not
    - Pay attention on how people react to you
    - Beware of micro-aggressions
    - Keep a list of "Things I Don't Know"
- [Signs that you're a good programmer](https://skatgame.net/mburo//courses/350/signs-that-you-re-a-good-programmer.html)¬†(not everything in here is great - some of the points are counterproductive)
    - The instinct to experiment first
    - Emotional detachment from code and design
    - Eager to fix what isn't broken
    - Fascinated by the incomprehensible
    - Compelled to teach
    - Incorruptible patience
    - A destructive pursuit of perfection
    - Encyclopedic grasp of the platform
    - Thinks In Code
    - When In Rome, Does As Romans Do
    - Creates their own tools
    - Indifferent to Hierarchy
    - Excited by failure
    - Indifferent to circumstances
    - Substitutes impulse for commitment
    - Driven by experiences
- [7 absolute truths I unlearned as junior developer](https://monicalent.com/blog/2019/06/03/absolute-truths-unlearned-as-junior-developer/)
    - Early in your career, you can learn 10x more in a supportive team in 1 year, than coding on your own
    - Every company has problems, every company has technical debt.
    - Being overly opinionated on topics you lack real-world experience with is pretty arrogant.
    - Many conference talks cover proof of concepts rather than real-world scenarios.
    - Dealing with legacy is completely normal.
    - Architecture is more important than nitpicking.
    - Focus on automation over documentation where appropriate.
    - Having some technical debt is healthy.
    - Senior engineers must develop many skills besides programming.
    - We‚Äôre all still junior in some areas.
- [How to Build Good Software](https://knowledge.csc.gov.sg/ethos-issue-21/how-to-build-good-software/)
    - A good high-level summary of fundamental engineering practices.
    - The root cause of bad software has less to do with specific engineering choices, and more to do with how development projects are managed.
    - There is no such thing as platonically good engineering: it depends on your needs and the practical problems you encounter.
    - Software should be treated not as a static product, but as a living manifestation of the development team‚Äôs collective understanding.
    - Software projects rarely fail because they are too small; they fail because they get too big.
    - Beware of bureaucratic goals masquerading as problem statements. If our end goal is to make citizens‚Äô lives better, we need to explicitly acknowledge the things that are making their lives worse.
    - Building software is not about avoiding failure; it is about strategically failing as fast as possible to get the information you need to build something good.
- [How to be a -10x Engineer](https://taylor.town/-10x)
    - Nullify the output of 10 engineers.
    - Hold 10 engineers hostage in a technical discussion.
    - Waste 10 weeks of wages on cloud costs.
    - Waste 400 hours of engineering on bad architecture.
    - Incur 400 hours of bug triage.